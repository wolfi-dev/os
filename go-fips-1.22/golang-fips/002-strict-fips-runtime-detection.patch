diff --git a/src/crypto/internal/backend/hostfips.go b/src/crypto/internal/backend/hostfips.go
new file mode 100644
index 0000000000..6fcd7139c6
--- /dev/null
+++ b/src/crypto/internal/backend/hostfips.go
@@ -0,0 +1,21 @@
+package backend
+
+import (
+	"fmt"
+	"os"
+)
+
+func hostFIPSModeEnabled() bool {
+	// Look at /proc/sys/crypto/fips_enabled to see if FIPS mode is enabled.
+	// If it is, log an error and exit.
+	// If we run into an error reading that file because it doesn't exist, assume FIPS mode is not enabled.
+	data, err := os.ReadFile("/proc/sys/crypto/fips_enabled")
+	if err != nil {
+		if os.IsNotExist(err) {
+			return false
+		}
+		fmt.Fprintf(os.Stderr, "error reading /proc/sys/crypto/fips_enabled: %v\n", err)
+		os.Exit(1)
+	}
+	return len(data) > 0 && data[0] == '1'
+}
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
index a27da89d4d..e1a78a0db3 100644
--- a/src/crypto/internal/backend/nobackend.go
+++ b/src/crypto/internal/backend/nobackend.go
@@ -17,6 +17,10 @@ import (
 	"io"
 )
 
+func init() {
+       strictFIPSNonCompliantBinaryCheck()
+}
+
 var enabled = false
 
 // Unreachable marks code that should be unreachable
@@ -43,13 +47,13 @@ func (randReader) Read(b []byte) (int, error) { panic("boringcrypto: not availab

 const RandReader = randReader(0)

-func Enabled() bool   { return false }
-func NewSHA1() hash.Hash   { panic("boringcrypto: not available") }
-func NewSHA224() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA256() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA384() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA512() hash.Hash { panic("boringcrypto: not available") }
-func SHA1(_ []byte) [20]byte { panic("boringcrypto: not available") }
+func Enabled() bool            { return false }
+func NewSHA1() hash.Hash       { panic("boringcrypto: not available") }
+func NewSHA224() hash.Hash     { panic("boringcrypto: not available") }
+func NewSHA256() hash.Hash     { panic("boringcrypto: not available") }
+func NewSHA384() hash.Hash     { panic("boringcrypto: not available") }
+func NewSHA512() hash.Hash     { panic("boringcrypto: not available") }
+func SHA1(_ []byte) [20]byte   { panic("boringcrypto: not available") }
 func SHA224(_ []byte) [28]byte { panic("boringcrypto: not available") }
 func SHA256(_ []byte) [32]byte { panic("boringcrypto: not available") }
 func SHA384(_ []byte) [48]byte { panic("boringcrypto: not available") }
@@ -86,7 +90,8 @@ func VerifyECDSA(pub *PublicKeyECDSA, hash, sig []byte) bool {

 type PublicKeyECDH struct{ _ int }
 type PrivateKeyECDH struct{ _ int }
-func (pc *PublicKeyECDH) Bytes() []byte { panic("boringcrypto: not available") }
+
+func (pc *PublicKeyECDH) Bytes() []byte                       { panic("boringcrypto: not available") }
 func (pc *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) { panic("boringcrypto: not available") }

 func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
diff --git a/src/crypto/internal/backend/not_strict_fips.go b/src/crypto/internal/backend/not_strict_fips.go
new file mode 100644
index 0000000000..f8e8fd6869
--- /dev/null
+++ b/src/crypto/internal/backend/not_strict_fips.go
@@ -0,0 +1,10 @@
+//go:build !goexperiment.strictfipsruntime
+// +build !goexperiment.strictfipsruntime
+
+package backend
+
+func strictFIPSOpenSSLRuntimeCheck() {
+}
+
+func strictFIPSNonCompliantBinaryCheck() {
+}
diff --git a/src/crypto/internal/backend/openssl.go b/src/crypto/internal/backend/openssl.go
index 45862eda3d..f431a7cdf4 100644
--- a/src/crypto/internal/backend/openssl.go
+++ b/src/crypto/internal/backend/openssl.go
@@ -19,6 +19,7 @@ import (
 var enabled bool
 
 func init() {
+	strictFIPSOpenSSLRuntimeCheck()
 	enabled = openssl.FIPS()
 }
 
diff --git a/src/crypto/internal/backend/strict_fips.go b/src/crypto/internal/backend/strict_fips.go
new file mode 100644
index 0000000000..894eeca942
--- /dev/null
+++ b/src/crypto/internal/backend/strict_fips.go
@@ -0,0 +1,23 @@
+//go:build goexperiment.strictfipsruntime
+// +build goexperiment.strictfipsruntime
+
+package backend
+
+import (
+	"fmt"
+	"os"
+)
+
+func strictFIPSOpenSSLRuntimeCheck() {
+	if hostFIPSModeEnabled() && !Enabled() {
+		fmt.Fprintln(os.Stderr, "FIPS mode is enabled, but the required OpenSSL backend is unavailable")
+		os.Exit(1)
+	}
+}
+
+func strictFIPSNonCompliantBinaryCheck() {
+	if hostFIPSModeEnabled() {
+		fmt.Fprintln(os.Stderr, "FIPS mode is enabled, but this binary is not compiled with FIPS compliant mode enabled")
+		os.Exit(1)
+	}
+}
diff --git a/src/internal/goexperiment/exp_strictfipsruntime_off.go b/src/internal/goexperiment/exp_strictfipsruntime_off.go
new file mode 100644
index 0000000000..73a676a18b
--- /dev/null
+++ b/src/internal/goexperiment/exp_strictfipsruntime_off.go
@@ -0,0 +1,9 @@
+// Code generated by mkconsts.go. DO NOT EDIT.
+
+//go:build !goexperiment.strictfipsruntime
+// +build !goexperiment.strictfipsruntime
+
+package goexperiment
+
+const StrictFIPSRuntime = false
+const StrictFIPSRuntimeInt = 0
diff --git a/src/internal/goexperiment/exp_strictfipsruntime_on.go b/src/internal/goexperiment/exp_strictfipsruntime_on.go
new file mode 100644
index 0000000000..0983612732
--- /dev/null
+++ b/src/internal/goexperiment/exp_strictfipsruntime_on.go
@@ -0,0 +1,9 @@
+// Code generated by mkconsts.go. DO NOT EDIT.
+
+//go:build goexperiment.strictfipsruntime
+// +build goexperiment.strictfipsruntime
+
+package goexperiment
+
+const StrictFIPSRuntime = true
+const StrictFIPSRuntimeInt = 1
diff --git a/src/internal/goexperiment/flags.go b/src/internal/goexperiment/flags.go
index 02e744362c..4ac7f480cf 100644
--- a/src/internal/goexperiment/flags.go
+++ b/src/internal/goexperiment/flags.go
@@ -100,4 +100,6 @@ type Flags struct {
 	// ExecTracer2 controls whether to use the new execution trace
 	// implementation.
 	ExecTracer2 bool
+
+	StrictFIPSRuntime bool
 }
