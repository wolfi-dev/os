package:
  name: liquibase
  version: "4.33.0"
  epoch: 4
  description: "Liquibase is a database schema change management solution that enables you to revise and release database changes faster and safer from development to production."
  copyright:
    - license: Apache-2.0
  dependencies:
    runtime:
      - liquibase-package-manager
      - openjdk-${{vars.java-version}}-default-jvm

vars:
  java-version: '17'

environment:
  contents:
    packages:
      - bash
      - build-base
      - busybox
      - maven
      - openjdk-${{vars.java-version}}-default-jdk
      - wolfi-base
  environment:
    LANG: en_US.UTF-8
    JAVA_HOME: /usr/lib/jvm/java-${{vars.java-version}}-openjdk

pipeline:
  - uses: git-checkout
    with:
      repository: https://github.com/liquibase/liquibase
      tag: v${{package.version}}
      expected-commit: 75773ed9b45b0a5adf3c42872d2e5494da669427

  - uses: maven/pombump
    working-directory: liquibase-dist
    with:
      properties-file: /home/build/pombump-properties.yaml

  - uses: maven/pombump
    with:
      properties-file: /home/build/pombump-properties-toplevel.yaml

  # This patch fixes an upstream dependency issue where they seem to have forgot to re-add a few dependencies after
  # removing them in version 4.32.0, in favor of "direct dependency for better dependabot control"
  - uses: patch
    with:
      patches: add-commons-dependencies.patch

  - name: Setup
    runs: |
      # Reversion liquibase.build.properties
      # REF: https://github.com/liquibase/liquibase/blob/master/.github/util/re-version.sh#L87
      sed -i -e "s/build.version=.*/build.version=${{package.version}}/" liquibase-standard/src/main/resources/liquibase.build.properties

  - name: Add verification markers to ensure build correctness
    runs: |
      # These help ensure that we're not accidentally downloading built artifacts from Maven rather than compiling
      # and using the source code. This can easily happen with one of the targets, `-pl liquibase-dist`, and is not
      # what we intend.

      # Add a datestamped string to the main targets
      mkdir -p liquibase-core/src/main/resources/
      mkdir -p liquibase-standard/src/main/resources/
      echo "WOLFI_CORE_${{package.version}}_$(date +%s)" > liquibase-core/src/main/resources/WOLFI_MARKER.txt
      echo "WOLFI_STANDARD_${{package.version}}_$(date +%s)" > liquibase-standard/src/main/resources/WOLFI_STANDARD.txt

      # Modify the internationalization properties file to make sure its not just bundling the above files with Maven assets
      sed -i 's/Starting Liquibase at/Starting Liquibase (Wolfi Build) at/' liquibase-standard/src/main/resources/liquibase/i18n/liquibase-core.properties

  - name: Build
    runs: |
      ./mvnw versions:set -DnewVersion="${{package.version}}"

      # Build with the patched pom
      echo "==> Building liquibase with fixed dependencies"
      ./mvnw -B clean package -DskipTests=true -P !liquibase-commercial

  - name: Install
    runs: |
      # Setup destination dir
      mkdir -p ${{targets.destdir}}/opt/java
      mkdir -p ${{targets.destdir}}/usr/share/java/liquibase
      tar -zxvf liquibase-dist/target/${{package.name}}-${{package.version}}.tar.gz -C ${{targets.destdir}}/usr/share/java/liquibase
      ln -sf /usr/lib/jvm/default-jvm ${{targets.destdir}}/opt/java/openjdk

  - name: Check verification markers
    runs: |
      # There was an issue where the following jar wasn't being included. Explicitly ensure that it is included
      test -f ${{targets.destdir}}/usr/share/java/liquibase/internal/lib/commons-collections4.jar

      # Upstream also has intended files lists, validate using those
      echo "==> Validating distribution contents against expected files"
      # List tarball contents, excluding directories (which end with /)
      tar -tzf liquibase-dist/target/${{package.name}}-${{package.version}}.tar.gz | grep -v '/$' | sort > actual-contents.txt

      # Check against the standard expected contents
      echo "Comparing with expected-distribution-contents.txt"
      # Filter out commercial components from expected files since we build with !liquibase-commercial
      grep -v 'liquibase-commercial.jar' liquibase-dist/expected-distribution-contents.txt | sort > expected-filtered.txt

      if diff -u expected-filtered.txt actual-contents.txt; then
        echo "✓ Distribution contents match expected"
      else
        echo "✗ Distribution contents differ from expected."
        echo "Missing files:"
        comm -13 actual-contents.txt expected-filtered.txt
        echo "Extra files:"
        comm -23 actual-contents.txt expected-filtered.txt
        exit 1
      fi

      # Save the timestamps from when we created the markers
      EXPECTED_CORE_MARKER=$(cat liquibase-core/src/main/resources/WOLFI_MARKER.txt)
      EXPECTED_STANDARD_MARKER=$(cat liquibase-standard/src/main/resources/WOLFI_STANDARD.txt)

      # Extract the tar.gz archive to a temp folder
      mkdir -p /tmp/liquibase-check
      tar -xzf liquibase-dist/target/liquibase-${{package.version}}.tar.gz -C /tmp/liquibase-check
      cd /tmp/liquibase-check

      # Check 1 & 2: Verify both WOLFI_MARKER and WOLFI_STANDARD markers in liquibase-core.jar
      echo "==> Checking liquibase-core.jar for verification markers"
      jar -xf internal/lib/liquibase-core.jar WOLFI_MARKER.txt WOLFI_STANDARD.txt 2>/dev/null || true

      # Check both markers exist and match exactly
      for marker_type in CORE STANDARD; do
        if [ "$marker_type" = "CORE" ]; then
          marker_file="WOLFI_MARKER.txt"
          marker_name="WOLFI_MARKER"
          expected_marker="$EXPECTED_CORE_MARKER"
          marker_label="core"
        else
          marker_file="WOLFI_STANDARD.txt"
          marker_name="WOLFI_STANDARD"
          expected_marker="$EXPECTED_STANDARD_MARKER"
          marker_label="standard"
        fi

        if [ -f "$marker_file" ]; then
          actual_marker=$(cat "$marker_file")
          echo "Expected $marker_label marker: $expected_marker"
          echo "Actual $marker_label marker:   $actual_marker"
          if [ "$actual_marker" = "$expected_marker" ]; then
            echo "✓ $marker_name matches exactly - using our build"
          else
            echo "✗ $marker_name doesn't match - not using our build!"
            exit 1
          fi
        else
          echo "✗✗✗ FAILURE: $marker_file not found in liquibase-core.jar"
          [ "$marker_type" = "CORE" ] && jar -tf internal/lib/liquibase-core.jar | head -20
          exit 1
        fi
      done

      # Check 3: Modified properties file contains "Wolfi Build" string
      echo "==> Checking for 'Wolfi Build' string in JAR"
      # Extract all files and search for our modification
      mkdir -p /tmp/jar-extract
      cd /tmp/jar-extract
      jar -xf /tmp/liquibase-check/internal/lib/liquibase-core.jar

      # Search all files for the "Wolfi Build" string
      if grep -r "Wolfi Build" . 2>/dev/null; then
        echo "✓ Found 'Wolfi Build' string in JAR contents"
      else
        echo "⚠ 'Wolfi Build' string NOT found in JAR"
        exit 1
      fi

      echo "✓✓✓ SUCCESS: All 3 markers match exactly - confirmed we're using locally compiled code!"

  - uses: strip

update:
  enabled: true
  github:
    identifier: liquibase/liquibase
    strip-prefix: v

test:
  environment:
    environment:
      SQLITE_URL: jdbc:sqlite:/tmp/test.db
      LIQUIBASE_HOME: /usr/share/java/liquibase
    contents:
      packages:
        - sqlite
        - bash
        - liquibase-package-manager
        - liquibase-docker
  pipeline:
    - name: Test CLI basics
      runs: |
        liquibase --version
    - name: Test Liquibase Changelogs
      runs: |
        # Setup sqlite database
        sqlite3 /tmp/test.db "CREATE TABLE test (id INT, name TEXT); INSERT INTO test VALUES (1, 'hello');"

        # Setup liquibase test project dir
        mkdir -p $LIQUIBASE_HOME/test

        # Create changlog file
        cat <<'EOF' >> $LIQUIBASE_HOME/test/example-changelog.sql
        --liquibase formatted sql

        --changeset your.name:1 labels:example-label context:example-context
        --comment: example comment
        create table person (
            id integer primary key autoincrement not null,
            name varchar(50) not null,
            address1 varchar(50),
            address2 varchar(50),
            city varchar(30)
        )
        --rollback DROP TABLE person;

        --changeset your.name:2 labels:example-label context:example-context
        --comment: example comment
        create table company (
            id integer primary key autoincrement not null,
            name varchar(50) not null,
            address1 varchar(50),
            address2 varchar(50),
            city varchar(30)
        )
        --rollback DROP TABLE company;

        --changeset other.dev:3 labels:example-label context:example-context
        --comment: example comment
        alter table person add column country varchar(2)
        --rollback ALTER TABLE person DROP COLUMN country;
        EOF

        cd $LIQUIBASE_HOME

        # Check status
        liquibase status --url="$SQLITE_URL" --changelog-file=test/example-changelog.sql

        # Inspect sql
        liquibase update-sql --url="$SQLITE_URL" --changelog-file=test/example-changelog.sql

        # Run changlog update
        liquibase update --url="$SQLITE_URL" --changelog-file=test/example-changelog.sql

        # Verify tables were created
        sqlite3 /tmp/test.db ".tables" | grep -q "company"
        sqlite3 /tmp/test.db ".tables" | grep -q "person"
    - name: Test rollback
      runs: |
        cd $LIQUIBASE_HOME

        # Tag the initial revision.
        liquibase --url="$SQLITE_URL" tag firsttag
        liquibase --url="$SQLITE_URL" history 2>/dev/null | grep -q firsttag

        # Rollout a new revision.
        cat <<"EOF" >$LIQUIBASE_HOME/test/update-changelog.sql
        --liquibase formatted sql
        -- ChangeSet your.name:add-column
        alter table company add column employees int;
        EOF
        liquibase --url="$SQLITE_URL" update --changelog-file=test/update-changelog.sql
        sqlite3 /tmp/test.db '.schema company' | grep -q employees

        # Tag the new revision.
        liquibase --url="$SQLITE_URL" tag secondtag
        liquibase --url="$SQLITE_URL" history 2>/dev/null | grep -q firsttag
        liquibase --url="$SQLITE_URL" history 2>/dev/null | grep -q secondtag

        # Rollback to the initial revision.
        liquibase --url="$SQLITE_URL" rollback --tag=firsttag --changelog-file=test/example-changelog.sql
    - name: Test XML changelog with Parameters
      runs: |
        cd $LIQUIBASE_HOME

        cat <<'EOF' >> $LIQUIBASE_HOME/test/example-changelog.xml
        <databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:pro="http://www.liquibase.org/xml/ns/pro"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-latest.xsd ">

        <property name="table.name" value="personXML" />

        <changeSet id="1" author="your.name" labels="example-label" context="example-context">
        <comment>example-comment</comment>
            <createTable tableName="${table.name}">
            <column name="id" type="int" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
                <column name="name" type="varchar(50)" />
                <column name="city" type="varchar(30)"/>
            </createTable>
        </changeSet>
        </databaseChangeLog>

        EOF

        liquibase update --url="$SQLITE_URL" -Dtable.name="personXML" --changelog-file=test/example-changelog.xml

        # Verify the table was created
        sqlite3 /tmp/test.db ".tables" | grep -q "personXML"
        sqlite3 /tmp/test.db ".schema personXML" | grep -q "city"
    - name: Test LPM CLI basics
      runs: |
        lpm --version
        lpm --help
    - name: Test LPM add operation
      runs: |
        # Add one package
        lpm add liquibase-postgresql@4.5.0

        # Verify package
        stat $(pwd)/liquibase_libs/liquibase-postgresql-4.5.0.jar

        # Add multiple packages
        lpm add mariadb snowflake sybase firebird sqlite

        # Verify packages
        for pkg in firebird-3.5.0.jar snowflake-jdbc-3.22.0.jar sqlite-jdbc-3.49.1.0.jar sybase-3.5.0.jar mariadb-java-client-3.5.2.jar; do
          find $(pwd)/liquibase_libs/ -name "$pkg" -type f
        done
    - name: Test LPM install
      runs: |
        # Remove liquibase_libs dir
        rm -rf $(pwd)/liquibase_libs

        # Test install from liquibase.json
        lpm install

        # Verify packages
        for pkg in liquibase-postgresql-4.5.0.jar firebird-3.5.0.jar snowflake-jdbc-3.22.0.jar sqlite-jdbc-3.49.1.0.jar sybase-3.5.0.jar mariadb-java-client-3.5.2.jar; do
          find $(pwd)/liquibase_libs/ -name "$pkg" -type f
        done
    - name: Test LPM remove
      runs: |
        # Remove installed packages
        lpm rm liquibase-postgresql mariadb snowflake sybase firebird sqlite
