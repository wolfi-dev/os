--- a/src/support/export_mgr.c	2026-01-08 15:18:07.403038594 -0500
+++ b/src/support/export_mgr.c	2026-01-08 15:18:27.058909332 -0500
@@ -939,6 +939,123 @@
 		auth_stats_time = clnt_allops_stats_time = nfs_stats_time;
 }
 
+/**
+ * @brief Handle the delegation option transition
+ */
+static void queue_deleg_transition_handler(struct fridgethr_context *ctx)
+{
+	/* Take the lock here to prevent a race condition between the
+	 * delegation transition handler and config updates.
+	 */
+	EXPORT_ADMIN_LOCK();
+	EXPORT_ADMIN_UNLOCK();
+
+	struct gsh_export *export = ctx->arg;
+	state_t *state;
+	struct glist_head *glist, *glistn;
+	sockaddr_t ip_address;
+	struct req_op_context op_context;
+	char *src = NULL;
+	nfs_client_id_t *clientid = NULL;
+	struct state_deleg *deleg = NULL;
+
+	/* Initializing the op_context with export and fsal_export */
+	init_op_context_simple(&op_context, export, export->fsal_export);
+
+	struct req_op_context *op_ctx = &op_context;
+
+	/* Loop through the export state list and check if any outstanding
+	 * delegations need to be recalled. Recall a delegation if the
+	 * delegation option was disabled in the config
+	 */
+	glist_for_each_safe(glist, glistn, &export->exp_state_list) {
+		struct fsal_obj_handle *obj = NULL;
+		state_owner_t *owner = NULL;
+
+		state = glist_entry(glist, state_t, state_export_list);
+
+		if (!get_state_obj_export_owner_refs(state, &obj, NULL,
+						     &owner)) {
+			/* This state_t is in the process of being destroyed,
+			 * skip it.
+			 */
+			continue;
+		}
+
+		PTHREAD_MUTEX_lock(&state->state_mutex);
+
+		/* Check only the delegation states */
+		if (state->state_type == STATE_TYPE_DELEG) {
+			clientid = owner->so_owner.so_nfs4_owner.so_clientrec;
+			src = clientid->gsh_client->hostaddr_str;
+
+			ip_str_to_sockaddr(src, &ip_address);
+
+			if (isMidDebug(COMPONENT_FSAL)) {
+				char scratch[SOCK_NAME_MAX];
+				struct display_buffer dspbuf = {
+					sizeof(scratch), scratch, scratch
+				};
+				display_sockip(&dspbuf, &ip_address);
+			}
+
+			/* Set the export and client IP address for the state
+			 * so that export_check_access() can evaluate the
+			 * effective options.
+			 */
+
+			op_ctx->ctx_export = export;
+			op_ctx->caller_addr = &ip_address;
+
+			/* Check the effective option derived from
+			 * EXPORT_DEFAULT, EXPORT, CLIENT block
+			 */
+			export_check_access();
+
+			deleg = &state->state_data.deleg;
+
+			/* Recall if there is an outstanding write or a read
+			 * delegation and the corresponding write or read
+			 * delegation was disabled in the config.
+			 */
+			if ((deleg->sd_type == OPEN_DELEGATE_WRITE &&
+			     !(op_ctx->export_perms.options &
+			       EXPORT_OPTION_WRITE_DELEG)) ||
+			    (deleg->sd_type == OPEN_DELEGATE_READ &&
+			     !(op_ctx->export_perms.options &
+			       EXPORT_OPTION_READ_DELEG))) {
+				LogFullDebug(
+					COMPONENT_FSAL,
+					"Deleg has been disabled. Recalling");
+
+				/* Asynchronous delegrecall per state
+				 * implementation.
+				 */
+				if (async_delegrecall_per_state(
+					    general_fridge, obj, state) != 0)
+					LogFullDebug(COMPONENT_FSAL,
+						     "Unable to recall");
+			}
+		}
+
+		PTHREAD_MUTEX_unlock(&state->state_mutex);
+	}
+}
+
+int async_deleg_transition_handler(struct fridgethr *fr,
+				   struct gsh_export *probe_exp)
+{
+	int rc = 0;
+
+	rc = fridgethr_submit(fr, queue_deleg_transition_handler, probe_exp);
+
+	if (rc != 0)
+		LogFullDebug(COMPONENT_FSAL, "fridgethr submit returned rc %d",
+			     rc);
+
+	return rc;
+}
+
 #ifdef USE_DBUS
 
 /* DBUS interfaces
@@ -1622,122 +1739,6 @@
 	PTHREAD_RWLOCK_unlock(&export_by_id.eid_lock);
 }
 
-/**
- * @brief Handle the delegation option transition
- */
-static void queue_deleg_transition_handler(struct fridgethr_context *ctx)
-{
-	/* Take the lock here to prevent a race condition between the
-	 * delegation transition handler and config updates.
-	 */
-	EXPORT_ADMIN_LOCK();
-	EXPORT_ADMIN_UNLOCK();
-
-	struct gsh_export *export = ctx->arg;
-	state_t *state;
-	struct glist_head *glist, *glistn;
-	sockaddr_t ip_address;
-	struct req_op_context op_context;
-	char *src = NULL;
-	nfs_client_id_t *clientid = NULL;
-	struct state_deleg *deleg = NULL;
-
-	/* Initializing the op_context with export and fsal_export */
-	init_op_context_simple(&op_context, export, export->fsal_export);
-
-	struct req_op_context *op_ctx = &op_context;
-
-	/* Loop through the export state list and check if any outstanding
-	 * delegations need to be recalled. Recall a delegation if the
-	 * delegation option was disabled in the config
-	 */
-	glist_for_each_safe(glist, glistn, &export->exp_state_list) {
-		struct fsal_obj_handle *obj = NULL;
-		state_owner_t *owner = NULL;
-
-		state = glist_entry(glist, state_t, state_export_list);
-
-		if (!get_state_obj_export_owner_refs(state, &obj, NULL,
-						     &owner)) {
-			/* This state_t is in the process of being destroyed,
-			 * skip it.
-			 */
-			continue;
-		}
-
-		PTHREAD_MUTEX_lock(&state->state_mutex);
-
-		/* Check only the delegation states */
-		if (state->state_type == STATE_TYPE_DELEG) {
-			clientid = owner->so_owner.so_nfs4_owner.so_clientrec;
-			src = clientid->gsh_client->hostaddr_str;
-
-			ip_str_to_sockaddr(src, &ip_address);
-
-			if (isMidDebug(COMPONENT_FSAL)) {
-				char scratch[SOCK_NAME_MAX];
-				struct display_buffer dspbuf = {
-					sizeof(scratch), scratch, scratch
-				};
-				display_sockip(&dspbuf, &ip_address);
-			}
-
-			/* Set the export and client IP address for the state
-			 * so that export_check_access() can evaluate the
-			 * effective options.
-			 */
-
-			op_ctx->ctx_export = export;
-			op_ctx->caller_addr = &ip_address;
-
-			/* Check the effective option derived from
-			 * EXPORT_DEFAULT, EXPORT, CLIENT block
-			 */
-			export_check_access();
-
-			deleg = &state->state_data.deleg;
-
-			/* Recall if there is an outstanding write or a read
-			 * delegation and the corresponding write or read
-			 * delegation was disabled in the config.
-			 */
-			if ((deleg->sd_type == OPEN_DELEGATE_WRITE &&
-			     !(op_ctx->export_perms.options &
-			       EXPORT_OPTION_WRITE_DELEG)) ||
-			    (deleg->sd_type == OPEN_DELEGATE_READ &&
-			     !(op_ctx->export_perms.options &
-			       EXPORT_OPTION_READ_DELEG))) {
-				LogFullDebug(
-					COMPONENT_FSAL,
-					"Deleg has been disabled. Recalling");
-
-				/* Asynchronous delegrecall per state
-				 * implementation.
-				 */
-				if (async_delegrecall_per_state(
-					    general_fridge, obj, state) != 0)
-					LogFullDebug(COMPONENT_FSAL,
-						     "Unable to recall");
-			}
-		}
-
-		PTHREAD_MUTEX_unlock(&state->state_mutex);
-	}
-}
-
-int async_deleg_transition_handler(struct fridgethr *fr,
-				   struct gsh_export *probe_exp)
-{
-	int rc = 0;
-
-	rc = fridgethr_submit(fr, queue_deleg_transition_handler, probe_exp);
-
-	if (rc != 0)
-		LogFullDebug(COMPONENT_FSAL, "fridgethr submit returned rc %d",
-			     rc);
-
-	return rc;
-}
 
 /**
  * @brief Update an export
