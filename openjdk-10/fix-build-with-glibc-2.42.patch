Author: Sergio Durigan Junior <sergiodj@chainguard.dev>
Description: Fix build with glibc 2.42

diff --git a/src/hotspot/cpu/aarch64/assembler_aarch64.cpp b/src/hotspot/cpu/aarch64/assembler_aarch64.cpp
index 57bc7b2..54c2bb2 100644
--- a/src/hotspot/cpu/aarch64/assembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/assembler_aarch64.cpp
@@ -1426,7 +1426,7 @@ void Assembler::add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int o
 
 bool Assembler::operand_valid_for_add_sub_immediate(long imm) {
   bool shift = false;
-  unsigned long uimm = uabs(imm);
+  unsigned long uimm = uabs_g(imm);
   if (uimm < (1 << 12))
     return true;
   if (uimm < (1 << 24)
diff --git a/src/hotspot/cpu/aarch64/assembler_aarch64.hpp b/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
index 2a9766f..2e520bb 100644
--- a/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
@@ -316,7 +316,7 @@ namespace ext
 
 // abs methods which cannot overflow and so are well-defined across
 // the entire domain of integer types.
-static inline unsigned int uabs(unsigned int n) {
+static inline unsigned int uabs_g(unsigned int n) {
   union {
     unsigned int result;
     int value;
@@ -325,7 +325,7 @@ static inline unsigned int uabs(unsigned int n) {
   if (value < 0) result = -result;
   return result;
 }
-static inline unsigned long uabs(unsigned long n) {
+static inline unsigned long uabs_g(unsigned long n) {
   union {
     unsigned long result;
     long value;
@@ -334,8 +334,8 @@ static inline unsigned long uabs(unsigned long n) {
   if (value < 0) result = -result;
   return result;
 }
-static inline unsigned long uabs(long n) { return uabs((unsigned long)n); }
-static inline unsigned long uabs(int n) { return uabs((unsigned int)n); }
+static inline unsigned long uabs_g(long n) { return uabs_g((unsigned long)n); }
+static inline unsigned long uabs_g(int n) { return uabs_g((unsigned int)n); }
 
 // Addressing modes
 class Address VALUE_OBJ_CLASS_SPEC {
@@ -575,7 +575,7 @@ class Address VALUE_OBJ_CLASS_SPEC {
   static bool offset_ok_for_immed(long offset, int shift = 0) {
     unsigned mask = (1 << shift) - 1;
     if (offset < 0 || offset & mask) {
-      return (uabs(offset) < (1 << (20 - 12))); // Unscaled offset
+      return (uabs_g(offset) < (1 << (20 - 12))); // Unscaled offset
     } else {
       return ((offset >> shift) < (1 << (21 - 10 + 1))); // Scaled, unsigned offset
     }
@@ -851,7 +851,7 @@ public:
   static const unsigned long branch_range = INCLUDE_JVMCI ? 128 * M : NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 
   static bool reachable_from_branch_at(address branch, address target) {
-    return uabs(target - branch) < branch_range;
+    return uabs_g(target - branch) < branch_range;
   }
 
   // Unconditional branch (immediate)
diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index 5bc06e3..85c6bee 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -2070,7 +2070,7 @@ void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned im
   if (operand_valid_for_add_sub_immediate((int)imm)) {
     (this->*insn1)(Rd, Rn, imm);
   } else {
-    if (uabs(imm) < (1 << 24)) {
+    if (uabs_g(imm) < (1 << 24)) {
        (this->*insn1)(Rd, Rn, imm & -(1 << 12));
        (this->*insn1)(Rd, Rd, imm & ((1 << 12)-1));
     } else {
diff --git a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
index a2515e5..a059838 100644
--- a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
@@ -1140,7 +1140,7 @@ class StubGenerator: public StubCodeGenerator {
 
   void copy_memory_small(Register s, Register d, Register count, Register tmp, int step) {
     bool is_backwards = step < 0;
-    size_t granularity = uabs(step);
+    size_t granularity = uabs_g(step);
     int direction = is_backwards ? -1 : 1;
     int unit = wordSize * direction;
 
@@ -1196,7 +1196,7 @@ class StubGenerator: public StubCodeGenerator {
                    Register count, Register tmp, int step) {
     copy_direction direction = step < 0 ? copy_backwards : copy_forwards;
     bool is_backwards = step < 0;
-    int granularity = uabs(step);
+    int granularity = uabs_g(step);
     const Register t0 = r3, t1 = r4;
 
     // <= 96 bytes do inline. Direction doesn't matter because we always
