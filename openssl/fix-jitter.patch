diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index 74b7d3d8ac..18608dc18c 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -2438,7 +2438,7 @@ static void core_self_test_get_callback(OPENSSL_CORE_CTX *libctx,
     OSSL_SELF_TEST_get_callback((OSSL_LIB_CTX *)libctx, cb, cbarg);
 }
 
-# ifdef OPENSSL_NO_FIPS_JITTER
+# ifdef OPENSSL_NO_JITTER
 static size_t rand_get_entropy(const OSSL_CORE_HANDLE *handle,
                                unsigned char **pout, int entropy,
                                size_t min_len, size_t max_len)
@@ -2446,6 +2446,14 @@ static size_t rand_get_entropy(const OSSL_CORE_HANDLE *handle,
     return ossl_rand_get_entropy((OSSL_LIB_CTX *)core_get_libctx(handle),
                                  pout, entropy, min_len, max_len);
 }
+
+static size_t rand_get_user_entropy(const OSSL_CORE_HANDLE *handle,
+                                    unsigned char **pout, int entropy,
+                                    size_t min_len, size_t max_len)
+{
+    return ossl_rand_get_user_entropy((OSSL_LIB_CTX *)core_get_libctx(handle),
+                                      pout, entropy, min_len, max_len);
+}
 # else
 /*
  * OpenSSL FIPS providers prior to 3.2 call rand_get_entropy API from
@@ -2470,15 +2478,22 @@ static size_t rand_get_entropy(const OSSL_CORE_HANDLE *handle,
 {
     return ossl_rand_jitter_get_seed(pout, entropy, min_len, max_len);
 }
-# endif
-
+/*
+ * If a 3.2+ provider calls rand_get_user_entropy, the seed rng might
+ * not yet be initialised, and creating it might not be possible yet
+ * either (as providers might still be loading). In these
+ * circumstances we still want to provide JITTER entropy to those
+ * providers.
+ */
 static size_t rand_get_user_entropy(const OSSL_CORE_HANDLE *handle,
                                     unsigned char **pout, int entropy,
                                     size_t min_len, size_t max_len)
 {
-    return ossl_rand_get_user_entropy((OSSL_LIB_CTX *)core_get_libctx(handle),
-                                      pout, entropy, min_len, max_len);
+    size_t ret = ossl_rand_jitter_get_seed(pout, entropy, min_len, max_len);
+    OPENSSL_assert(ret > 0);
+    return ret;
 }
+# endif
 
 static void rand_cleanup_entropy(const OSSL_CORE_HANDLE *handle,
                                  unsigned char *buf, size_t len)
diff --git a/providers/implementations/rands/seed_src_jitter.c.in b/providers/implementations/rands/seed_src_jitter.c.in
index 4d73f07574..35c7752c17 100644
--- a/providers/implementations/rands/seed_src_jitter.c.in
+++ b/providers/implementations/rands/seed_src_jitter.c.in
@@ -299,7 +299,6 @@ static size_t jitter_get_seed(void *vseed, unsigned char **pout,
     return ret;
 }
 
-# ifndef OPENSSL_NO_FIPS_JITTER
 size_t ossl_rand_jitter_get_seed(unsigned char **pout, int entropy, size_t min_len, size_t max_len)
 {
     size_t ret = 0;
@@ -315,7 +314,6 @@ size_t ossl_rand_jitter_get_seed(unsigned char **pout, int entropy, size_t min_l
     jitter_free(s);
     return ret;
 }
-# endif
 
 static void jitter_clear_seed(ossl_unused void *vdrbg,
                               unsigned char *out, size_t outlen)
