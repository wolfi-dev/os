name: Check Daemon Output

description: |
  Starts a daemon/server, waits for expected log output, optionally runs post-startup checks, then cleans up.

  USE THIS PIPELINE WHEN:
  - You need to start a server/daemon and verify it starts correctly
  - You need to wait for specific log messages indicating readiness
  - You want to run commands after the daemon is ready (health checks, client operations, etc.)
  - You need automatic cleanup even if tests fail

  EXAMPLES:

  Example 1 - Basic daemon startup verification:
    - uses: test/daemon-check-output
      with:
        start: /use/bin/foo/mydaemon --config /tmp/config.yaml
        expected_output: "Server listening on port"

  Example 2 - Setup config, start daemon, verify with curl:
    - uses: test/daemon-check-output
      with:
        setup: |
          mkdir -p /tmp/daemon-data
          tee /tmp/config.yaml <<EOF
          port: 8080
          dataDir: /tmp/daemon-data
          EOF
        start: /use/bin/foo/mydaemon --config /tmp/config.yaml
        expected_output: "Server started successfully"
        post: |
          curl -f http://localhost:8080/health

  Example 3 - ZooKeeper example with client operations:
    - uses: test/daemon-check-output
      with:
        setup: |
          mkdir -p /tmp/zk/data
          tee /tmp/zoo.cfg <<EOF
          tickTime=2000
          dataDir=/tmp/zk/data
          clientPort=2181
          EOF
        start: /usr/share/java/zookeeper/bin/zkServer.sh start /tmp/zoo.cfg
        expected_output: "binding to port"
        post: |
          # Test client can connect and perform operations
          echo "create /test mydata" | zkCli.sh -server localhost:2181
          echo "get /test" | zkCli.sh -server localhost:2181 | grep -F mydata

  Example 4 - Wait for port without specific log message:
    - uses: test/daemon-check-output
      with:
        start: myserver --port 9000
        expected_output: "."  # Matches any output
        post: |
          # Use wait-for-it or netcat to verify port
          wait-for-it localhost:9000 -t 30
          curl http://localhost:9000/api/status

  DAEMON DEPENDENCIES:
  - Each test/daemon-check-output step is ISOLATED - daemons stop after the step completes
  - If service A depends on service B running:
    CORRECT: Start B in A's setup script
    WRONG: Create separate test step for B (it will stop before A runs)
  - Example: Kafka needs ZooKeeper â†’ start ZooKeeper in Kafka test's setup script

needs:
  packages:
    - busybox
    - wait-for-it

inputs:
  start:
    description: |
      The command to run to start the daemon.

      IMPORTANT: Use absolute paths, NOT cd && command patterns.
      CORRECT: "/usr/lib/kafka/bin/kafka-server-start.sh /usr/lib/kafka/config/server.properties"
      WRONG: "cd /usr/lib/kafka && bin/kafka-server-start.sh config/server.properties"

      More examples:
      - "/usr/share/java/zookeeper/bin/zkServer.sh start /tmp/zoo.cfg"
      - "/usr/bin/redis-server --port 6379"
      - "nginx -c /etc/nginx/nginx.conf"
    required: true
  setup:
    description: |
      Optional setup commands to run BEFORE starting the daemon.
      Use this to create directories, generate config files, set environment variables, etc.
      If no shebang is present, '#!/bin/sh -ex' will be prepended.

      IMPORTANT: wait-for-it is pre-installed and available for use.
      USE: "wait-for-it localhost:2181 -t 30" to wait for port availability
      AVOID: Custom for loops with sleep and grep - use wait-for-it instead

      Example:
        setup: |
          mkdir -p /tmp/myapp/data /tmp/myapp/logs
          export MYAPP_HOME=/tmp/myapp
          tee /tmp/myapp/config.yaml <<EOF
          port: 8080
          logLevel: debug
          EOF

      Example with dependency daemon:
        setup: |
          /usr/share/java/zookeeper/bin/zkServer.sh start /tmp/zoo.cfg &
          wait-for-it localhost:2181 -t 30
    required: false
  post:
    description: |
      Optional commands to run AFTER the daemon has started and expected_output is found.
      Use this to verify the daemon is working correctly - run health checks, test client
      connections, perform basic operations, etc.
      Handled just like setup (gets '#!/bin/sh -ex' prepended if no shebang).

      IMPORTANT: wait-for-it is pre-installed and available.
      Use it to wait for ports if you need to verify connectivity before running tests.

      Example:
        post: |
          curl -f http://localhost:8080/health
          echo "ping" | nc localhost 6379 | grep -F PONG

      Example with JSON validation:
        post: |
          response=$(curl -sf http://localhost:8080/api/status)
          echo "$response" | jq -e '.status == "OK"'
    required: false
  timeout:
    description: |
      Maximum time in seconds to wait for expected_output to appear in daemon logs.
      Default: 30 seconds

      Example: timeout: "60"  # Wait up to 60 seconds for daemon to be ready
    default: 30
  expected_output:
    description: |
      Newline-separated list of regex patterns that must appear in the daemon's output.
      The pipeline waits until ALL patterns are found (or timeout is reached).

      Common patterns:
      - "Server listening on port" - HTTP servers
      - "binding to port" - ZooKeeper
      - "ready to accept connections" - databases
      - "." - matches any output (use when no specific message available)

      Example (multiple patterns - all must be found):
        expected_output: |
          Server listening on port 8080
          Database connection established
    required: true
  error_strings:
    description: |
      Newline-separated list of regex patterns that indicate errors in daemon output.
      If any pattern is found, the test FAILS.
      Set to empty string to disable error checking.

      Default patterns detect: ERROR, FAIL, FATAL, Java/Python/Ruby exceptions,
      and "command not found".

      Example (disable error checking):
        error_strings: ""

      Example (custom patterns):
        error_strings: |
          Connection refused
          Timeout exceeded
          Out of memory
    required: true
    default: |
      ERROR
      FAIL
      FATAL
      Traceback.*most.recent.call
      Exception in thread
      java.lang.NullPointerException
      java.lang.RuntimeException
      Gem::MissingSpecError
      command not found

pipeline:
  - name: "start daemon on localhost"
    runs: |
      info() { echo "$@"; }
      # term_wait_kill(pid, ttime, ktime)
      # wait ttime seconds, send SIGTERM to pid
      # then wait up to stime seconds for pid to die.
      # if it is still alive after ktime more seconds, SIGKILL it.
      term_wait_kill() {
        local pid="$1" ttime="$2" ktime="$3" n="" killrc="0"
        n=0
        [ -d "/proc/$pid" ] || {
          info "twk: pid $pid did not exist"
          return 0
        }
        while [ $n -lt $ttime ] && n=$((n+1)); do
            if [ ! -d "/proc/$pid" ]; then
                info "twk: pid $pid did not exist after $n seconds"
                return 0
            fi
            sleep 1
        done
        if [ ! -d "/proc/$pid" ]; then
            info "twk: pid $pid died on its own within $n seconds"
            return 0
        fi
        kill -TERM "$pid" || killrc=$?
        info "twk: SIGTERM sent to pid $pid. kill returned $killrc."
        n=0
        while [ $n -lt $ktime ] && n=$((n+1)); do
            if [ ! -d "/proc/$pid" ]; then
                info "twk: pid $pid exited within $n seconds after SIGTERM"
                return 0
            fi
            sleep 1
        done
        if [ ! -d "/proc/$pid" ]; then
            info "twk: pid $pid exited within $n seconds after SIGTERM"
            return 0
        fi
        kill -KILL "$pid" || killrc=$?
        info "twk: SIGKILL sent to pid $pid [kill returned $killrc]"
        return 0
      }

      cleanup() {
        # stop subshells from cleaning up.
        if [ "$$" != "$MAINPID" ]; then
            return 0
        fi
        rm -Rf "$TMPD"
      }

      set +x
      MAINPID=$$
      TMPD=$(mktemp -d)
      trap cleanup EXIT
      KID=""
      OUT_F="${TMPD}/out"
      EXPECTED_F="${TMPD}/expected"
      MISSING_F="${TMPD}/missing"
      ERRORS_F="${TMPD}/errorstrings"
      ERRORS_FOUND_F="${TMPD}/errorstrings-found"
      SETUP_F="${TMPD}/setup"
      POST_F="${TMPD}/post"
      rc=0

      timeout=${{inputs.timeout}}

      # Write inputs to temp files using heredocs to avoid single-quote escaping issues.
      # The quoted delimiter (<<'EOF') prevents any shell expansion in the content.
      cat > "${TMPD}/setup_input" <<'MELANGE_SETUP_EOF'
      ${{inputs.setup}}
      MELANGE_SETUP_EOF
      setup=$(cat "${TMPD}/setup_input")

      cat > "${EXPECTED_F}" <<'MELANGE_EXPECTED_EOF'
      ${{inputs.expected_output}}
      MELANGE_EXPECTED_EOF

      cat > "${ERRORS_F}" <<'MELANGE_ERRORS_EOF'
      ${{inputs.error_strings}}
      MELANGE_ERRORS_EOF
      error_strings=$(cat "${ERRORS_F}")

      cat > "${TMPD}/post_input" <<'MELANGE_POST_EOF'
      ${{inputs.post}}
      MELANGE_POST_EOF
      post=$(cat "${TMPD}/post_input")

      set --
      while read line ; do
          [ "$line" = "" ] && continue
          set -- "$@" "$line"
      done < "$EXPECTED_F"
      num_lines=$#

      if [ -n "$setup" ]; then
          shbang="#!"
          # correct/documented behavior is disabled for now so that scripts do not run with set -e
          if false FIXME see pr-44792 && [ "${setup#${shbang}}" != "$setup" ]; then
              printf "%s\n" '#!/bin/sh -ex' > "${SETUP_F}"
          fi
          printf "%s\n" "$setup" >> "${SETUP_F}"
          chmod 755 "${SETUP_F}"
          info "running setup from ${SETUP_F}"
          "${SETUP_F}" || {
            rc=$?
            info "ERROR: setup failed with $rc"
            exit $rc
          }
      fi

      if [ -n "$post" ]; then
          shbang="#!"
          # correct/documented behavior is disabled for now so that scripts do not run with set -e
          if false FIXME see pr-44792 && [ "${post#${shbang}}" = "$post" ]; then
              printf "%s\n" '#!/bin/sh -ex' > "${POST_F}"
          fi
          printf "%s\n" "$post" >> "${POST_F}"
          chmod 755 "${POST_F}"
      fi

      set -- ${{inputs.start}}
      n=$#
      "$@" >"$OUT_F" 2>&1 </dev/null &
      KID=$!
      info "daemon started as pid $KID with: $*"
      info "looking for ${num_lines} lines in output within $timeout seconds"

      set --
      while read line ; do
          [ "$line" = "" ] && continue
          set -- "$@" "$line"
      done < "$EXPECTED_F"
      found=0

      n=0
      while n=$((n+1)); do
          while [ $# -gt 0 ] && grep -q "$1" "$OUT_F"; do
              info "found within $n seconds: $1"
              found=$((found+1))
              shift
          done
          [ $# -eq 0 ] && break
          [ -d "/proc/$KID" ] || {
             wait $KID || rc=$?
             info "process $KID died inside $n seconds. exited $rc"
             break;
          }
          if [ $n -gt $timeout ]; then
              info "timeout $timeout seconds reached."
              break
          fi
          sleep 1
      done

      while [ $# -ne 0 ]; do
          if grep -q "$1" "$OUT_F"; then
              info "found within $n seconds: $1"
              found=$((found+1))
          else
              info "missing expected output: $1"
              echo "$1" >> "$MISSING_F"
          fi
          shift
      done

      # now look for errors.
      errors_found=0
      num_error_strings=0
      if [ -z "${error_strings}" ]; then
          info "error string checking is disabled."
      else
          set --
          while read line ; do
              [ "$line" = "" ] && continue
              set -- "$@" "$line"
          done < "$ERRORS_F"
          num_error_strings=$#
          for errmsg in "$@"; do
              if out=$(grep "$errmsg" "$OUT_F"); then
                  info "ERROR: found error message '$errmsg' in output: $out"
                  errors_found=$((errors_found+1))
                  echo "$errmsg" >> "$ERRORS_FOUND_F"
              fi
          done
      fi

      if [ -f "$POST_F" ]; then
          info "running post from ${POST_F}"
          "${POST_F}" || {
            rc=$?
            info "ERROR: post failed with $rc"
          }
      fi

      info "-- begin output --"
      sed 's,^,> ,' "$OUT_F"
      info "-- end   output --"

      if [ $num_lines -eq 1 ]; then
          line_str="line"
      else
          line_str="lines"
      fi
      if [ $found -ne $num_lines ]; then
          rc=1
          info "ERROR: found $found of expected ${num_lines} ${line_str} in output."
          info "missing:"
          sed 's,^,> ,' "$MISSING_F"
      else
          info "found $found of expected ${num_lines} ${line_str} in output."
      fi

      if [ $errors_found -ne 0 ]; then
          rc=1
          info "ERROR: matched ${errors_found} error strings below in output above:"
          sed 's,^,> ,' "$ERRORS_FOUND_F"
      elif [ $num_error_strings -ne 0 ]; then
          info "found 0 / ${num_error_strings} error strings in output."
      fi

      term_wait_kill "$KID" 0 30
      wait || info "wait returned $?"
      exit $rc
