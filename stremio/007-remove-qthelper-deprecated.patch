Description: Use minimal inline qthelper implementation for MPV integration
 Replace external qthelper.hpp dependency with minimal inline implementation.
 This patch removes the need for the external qthelper library by embedding
 only the essential functions directly in mpv.cpp.
 .
 Changes:
  - Remove #include <mpv/qthelper.hpp> from mpv.h
  - Add minimal qthelper namespace with 4 essential functions in mpv.cpp
  - Adapt mpv_opengl_init_params structure for current MPV version (2 params)
 .
 This follows Debian packaging best practices by using system libraries
 while maintaining full MPV functionality with minimal code duplication.
Author: Juan Manuel Méndez Rey <vejeta@gmail.com>
Bug-Debian: https://bugs.debian.org/943703
Forwarded: no
Last-Update: 2025-09-30

Index: stremio/mpv.cpp
===================================================================
--- stremio.orig/mpv.cpp
+++ stremio/mpv.cpp
@@ -20,6 +20,107 @@
 #pragma comment (lib, "dwmapi.lib")
 #endif
 
+// Minimal qthelper functionality for Qt/MPV integration
+namespace mpv {
+namespace qt {
+
+static inline QVariant node_to_variant(const mpv_node *node)
+{
+    switch (node->format) {
+    case MPV_FORMAT_STRING:
+        return QVariant(QString::fromUtf8(node->u.string));
+    case MPV_FORMAT_FLAG:
+        return QVariant(static_cast<bool>(node->u.flag));
+    case MPV_FORMAT_INT64:
+        return QVariant(static_cast<qlonglong>(node->u.int64));
+    case MPV_FORMAT_DOUBLE:
+        return QVariant(node->u.double_);
+    case MPV_FORMAT_NODE_ARRAY: {
+        mpv_node_list *list = node->u.list;
+        QVariantList qlist;
+        for (int n = 0; n < list->num; n++)
+            qlist.append(node_to_variant(&list->values[n]));
+        return QVariant(qlist);
+    }
+    case MPV_FORMAT_NODE_MAP: {
+        mpv_node_list *list = node->u.list;
+        QVariantMap qmap;
+        for (int n = 0; n < list->num; n++) {
+            qmap.insert(QString::fromUtf8(list->keys[n]),
+                        node_to_variant(&list->values[n]));
+        }
+        return QVariant(qmap);
+    }
+    default: // MPV_FORMAT_NONE, unknown values
+        return QVariant();
+    }
+}
+
+static mpv_node build_node(const QVariant &v) {
+    mpv_node node;
+    if (v.type() == QVariant::String) {
+        node.format = MPV_FORMAT_STRING;
+        QByteArray ba = v.toString().toUtf8();
+        char *str = new char[ba.size() + 1];
+        strcpy(str, ba.data());
+        node.u.string = str;
+    } else if (v.type() == QVariant::Bool) {
+        node.format = MPV_FORMAT_FLAG;
+        node.u.flag = v.toBool() ? 1 : 0;
+    } else if (v.type() == QVariant::Int || v.type() == QVariant::LongLong) {
+        node.format = MPV_FORMAT_INT64;
+        node.u.int64 = v.toLongLong();
+    } else if (v.type() == QVariant::Double) {
+        node.format = MPV_FORMAT_DOUBLE;
+        node.u.double_ = v.toDouble();
+    } else {
+        node.format = MPV_FORMAT_NONE;
+    }
+    return node;
+}
+
+static void free_node(mpv_node *node) {
+    if (node->format == MPV_FORMAT_STRING) {
+        delete[] node->u.string;
+    }
+    node->format = MPV_FORMAT_NONE;
+}
+
+static inline QVariant get_property(mpv_handle *ctx, const QString &name) {
+    mpv_node node;
+    int err = mpv_get_property(ctx, name.toUtf8().data(), MPV_FORMAT_NODE, &node);
+    if (err < 0)
+        return QVariant();
+    QVariant result = node_to_variant(&node);
+    mpv_free_node_contents(&node);
+    return result;
+}
+
+static inline int set_property(mpv_handle *ctx, const QString &name, const QVariant &v) {
+    mpv_node node = build_node(v);
+    int result = mpv_set_property(ctx, name.toUtf8().data(), MPV_FORMAT_NODE, &node);
+    free_node(&node);
+    return result;
+}
+
+static inline QVariant command(mpv_handle *ctx, const QVariant &args) {
+    if (args.canConvert<QStringList>()) {
+        QStringList list = args.toStringList();
+        const char **c_args = new const char*[list.size() + 1];
+        for (int i = 0; i < list.size(); i++) {
+            c_args[i] = list[i].toUtf8().data();
+        }
+        c_args[list.size()] = nullptr;
+        int err = mpv_command(ctx, c_args);
+        delete[] c_args;
+        return err < 0 ? QVariant() : QVariant(0);
+    }
+    return QVariant();
+}
+
+} // namespace qt
+} // namespace mpv
+
 namespace
 {
 void on_mpv_redraw(void *ctx)
@@ -65,7 +166,7 @@ class MpvRenderer : public QQuickFrameb
         // init mpv_gl:
         if (!obj->mpv_gl)
         {
-            mpv_opengl_init_params gl_init_params{get_proc_address_mpv, nullptr, nullptr};
+            mpv_opengl_init_params gl_init_params{get_proc_address_mpv, nullptr};
             mpv_render_param params[]{
                 {MPV_RENDER_PARAM_API_TYPE, const_cast<char *>(MPV_RENDER_API_TYPE_OPENGL)},
                 {MPV_RENDER_PARAM_OPENGL_INIT_PARAMS, &gl_init_params},
Index: stremio/mpv.h
===================================================================
--- stremio.orig/mpv.h
+++ stremio/mpv.h
@@ -6,7 +6,6 @@
 
 #include <mpv/client.h>
 #include <mpv/render_gl.h>
-#include <mpv/qthelper.hpp>
 
 class MpvRenderer;
 

```

Command completed.

The previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.</function_calls>
<system_warning>Token usage: 157854/1000000; 842146 remaining</system_warning>

¡Perfecto! El patch de Debian hace **dos cambios en dos archivos diferentes** (mpv.cpp Y mpv.h) en un solo patch. Voy a guardar este patch correctamente:

<function_calls>
<invoke name="run_terminal_cmd">
<parameter name="command">curl -s "https://salsa.debian.org/mendezr/stremio/-/raw/master/debian/patches/0004-minimal-qthelper-integration.patch" > /Users/jmy99/development/misc/wolfi/wolfi-os/stremio/007-remove-qthelper-deprecated.patch